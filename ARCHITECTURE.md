# Архитектура WebJARVIS

## Обзор системы

WebJARVIS - автономный AI-агент для автоматизации браузера, использующий OpenAI GPT-4o и Playwright. Система спроектирована для выполнения сложных многошаговых задач без постоянного участия пользователя.

## Основные компоненты

### 1. MainAgent (`src/agent/main_agent.py`)
**Ответственность:** Основной цикл выполнения задач (OBSERVE-DECIDE-ACT-REFLECT)

**Ключевые методы:**
- `execute_task()` - главный цикл выполнения задачи с отслеживанием прогресса
- `_decide_action()` - принятие решения через OpenAI API с учетом контекста
- `_execute_action()` - выполнение действия с проверкой безопасности
- `_build_user_message()` - формирование промпта с историей и предупреждениями о циклах
- `stop()` - остановка выполнения задачи

**Состояния агента:**
- IDLE - бездействие
- OBSERVING - наблюдение за страницей
- DECIDING - принятие решения
- ACTING - выполнение действия
- REFLECTING - анализ результата
- WAITING_USER - ожидание пользователя (не используется в автономном режиме)
- COMPLETED - задача выполнена
- ERROR - ошибка

**Особенности:**
- Отслеживание изменений страницы (URL, заголовок, DOM-хеш)
- Обнаружение новых элементов (модальные окна, формы)
- Агрессивное обнаружение циклов с предупреждениями
- Интеграция с ErrorHandler для анализа ошибок
- Поддержка динамического контента (SPA, AJAX, lazy loading)

### 2. BrowserController (`src/browser/controller.py`)
**Ответственность:** Управление браузером через Playwright

**Возможности:**
- Запуск браузера (headless/visible через конфиг)
- Persistent sessions через `launch_persistent_context`
- Навигация с retry логикой и ожиданием загрузки
- Клики, ввод текста, прокрутка
- Проверка видимости элементов
- Выполнение JavaScript на странице
- Создание скриншотов

**Методы клика:**
- `click()` - основной метод клика через Playwright locator.click()
  - Параметр `use_mouse_fallback` - автоматический fallback на Mouse API при ошибках
  - Автоматически ждет видимости, прокручивает, ждет стабильности элемента
- `click_with_mouse_events()` - клик через реальные события мыши (Mouse API)
  - Используется как fallback когда обычный клик не работает
  - Эмулирует реальные события mousedown, mouseup, click
  - Особенно полезно для сайтов с JavaScript обработчиками событий

**Особенности:**
- Улучшенная прокрутка через `mouse.wheel()` с fallback на JavaScript
- Отслеживание позиции прокрутки и обнаружение конца страницы
- Retry логика для навигации с экспоненциальной задержкой
- Поддержка прокрутки до конкретного элемента
- Автоматический fallback на Mouse API для надежных кликов

### 3. PageExtractor (`src/browser/page_extractor.py`)
**Ответственность:** Извлечение структурированной информации со страницы

**Извлекает:**
- Интерактивные элементы (кнопки, ссылки, поля ввода, карточки)
- Видимый текст страницы (с приоритетом основному контенту)
- Метаданные (title, description, viewport)
- Информацию о модальных окнах и формах
- Состояние страницы (DOM-хеш, количество элементов)

**Поиск элементов:**
- Использует Playwright locator API (`get_by_text`, `get_by_role`)
- 7 стратегий поиска с fallback:
  1. Поиск через `get_by_text` с fuzzy matching
  2. Поиск по role (button, link)
  3. Поиск по aria-label
  4. Поиск по изображениям и alt-тексту
  5. Поиск в динамически загружаемых элементах (после прокрутки)
  6. Поиск в интерактивных элементах
  7. JavaScript fallback поиск
- Приоритизация элементов (модальные окна > формы > элементы с id)
- Кэширование результатов поиска на время итерации
- Обнаружение элементов в модальных окнах и формах

**Работа с кликабельными элементами:**
- `find_clickable_descendant()` - универсальный поиск кликабельного элемента внутри контейнера
  - Сначала проверяет кликабельность самого контейнера (cursor: pointer, обработчики событий)
  - Ищет кликабельные потомки с приоритетом элементов с большой областью клика
  - Агрессивно исключает вспомогательные элементы (avatar, icon, badge)
  - Минимальный размер элемента: 2000px² для основных элементов, 1500px² для fallback
- `find_clickable_ancestor()` - поиск кликабельного предка для некликабельных элементов

**Особенности:**
- Улучшенное извлечение текста элементов (aria-label, title, innerText)
- Обнаружение модальных окон по множественным признакам
- Извлечение контекста местоположения (breadcrumbs, секции)
- Поиск поисковой строки на странице
- Нормализация селекторов (удаление нестабильных позиционных псевдоклассов)

### 4. ContextManager (`src/context/manager.py`)
**Ответственность:** Управление контекстом для AI с учетом лимитов токенов

**Компоненты:**
- `TokenOptimizer` - оптимизация размера контекста
- `ContextExtractor` - извлечение релевантных элементов

**Стратегии оптимизации:**
- Умная обрезка истории действий (сохранение важных действий)
- Ограничение количества элементов с приоритизацией
- Усечение текста страницы
- Агрессивная оптимизация при превышении лимитов
- Отслеживание извлеченной информации и выполненных шагов

**Ограничения:**
- MAX_CONTEXT_TOKENS = 3000 (контекст страницы)
- MAX_HISTORY_TOKENS = 2000 (история действий)
- MAX_REQUEST_TOKENS = 25000 (весь запрос)

**Особенности:**
- Сохранение информации о прогрессе задачи (completed_steps)
- Отслеживание извлеченной информации (extracted_info)
- Добавление информации о модальных окнах и местоположении
- Динамическая оптимизация при превышении лимитов

### 5. ActionExecutor (`src/actions/action_executor.py`)
**Ответственность:** Выполнение действий агента

**Действия:**
- `click_element` - клик по элементу с обработкой модальных окон
  - Автоматический fallback на Mouse API при неудаче обычного клика
  - Улучшенная обработка контейнеров (list_item, card) с поиском кликабельных потомков
  - Нормализация селекторов (удаление нестабильных позиционных псевдоклассов)
  - Приоритизация контейнеров с делегированием событий
- `query_dom` - задать вопрос DOM Sub-agent'у о структуре страницы
  - Получение информации о элементах, их селекторах и визуальном состоянии
  - Извлечение селекторов из ответов для последующего использования
  - Кэширование вопросов для предотвращения повторений
- `type_text` - ввод текста (поддержка многострочных полей)
- `navigate` - переход по URL или поиск на странице
- `scroll` - прокрутка страницы или до элемента
- `extract_text` - извлечение текста с множественными стратегиями (закомментировано, используется query_dom)
- `wait_for_element` - ожидание элемента
- `take_screenshot` - создание скриншота с Vision API анализом
- `search_on_page` - поиск через поисковую строку
- `reload_page` - перезагрузка страницы
- `task_complete` - завершение задачи

**Особенности:**
- Автоматический поиск элементов по описанию (7 стратегий)
- Умная обработка модальных окон (не закрывает формы)
- Закрытие overlay и баннеров перед кликом
- Прокрутка до элемента перед взаимодействием
- Retry логика для кликов с обработкой перехватывающих элементов
  - Автоматический fallback на Mouse API при неудаче обычного клика
  - Fallback при успешном клике, но отсутствии изменения страницы
- Поддержка многострочных полей (textarea) через `fill()`
- Обнаружение появления модальных окон после клика
- Множественные стратегии извлечения текста (включая неинтерактивные элементы)
- Интеграция с DOM Sub-agent для получения информации о структуре страницы

### 6. SecurityLayer (`src/security/security_layer.py`)
**Ответственность:** Проверка деструктивных действий

**Категории опасности:**
- payment - оплата/покупка
- deletion - удаление данных
- sending - отправка данных
- modification - изменение данных
- confirmation - подтверждение действий

**Механизм:**
- Определение опасных действий по ключевым словам
- Запрос подтверждения у пользователя через callback
- Логирование деструктивных действий
- Форматирование описаний действий для пользователя

### 7. ErrorHandler (`src/error/error_handler.py`)
**Ответственность:** Адаптивная обработка ошибок

**Стратегии повтора:**
- scroll - прокрутка страницы
- scroll_to_element - прокрутка до элемента
- wait - ожидание загрузки
- alternative - альтернативный подход
- alternative_description - использование другого описания элемента
- close_modals - закрытие модальных окон
- use_search - использование поисковой строки

**Особенности:**
- Анализ ошибок через AI (OpenAI API)
- Паттерн-матчинг для типичных ошибок (ErrorPatternMatcher)
- Кэширование решений для повторяющихся ошибок
- История ошибок для предотвращения циклов
- Лимит попыток повтора (max_retries = 3)
- Извлечение стратегии из предложений AI

### 8. SubAgentManager (`src/agent/sub_agents.py`)
**Ответственность:** Управление специализированными sub-агентами

**Типы агентов:**
- **DOM Sub-agent** - анализ структуры DOM и элементов страницы
  - Отвечает на вопросы о структуре страницы через `query_dom`
  - Предоставляет детальную информацию о визуальном состоянии элементов
  - Возвращает селекторы элементов с описанием их состояния
  - Анализирует контекст запроса и предоставляет релевантную информацию
  
- **NavigationAgent** - навигация и поиск элементов
  - Анализ структуры страницы и элементов навигации
  - Учет SPA навигации и динамического контента
  - Предотвращение циклов навигации
  
- **FormAgent** - работа с формами
  - Анализ полей формы и их назначения
  - Работа с модальными окнами с формами
  - Учет AJAX отправки форм
  
- **ReadingAgent** - чтение и извлечение информации
  - Анализ структуры данных на странице
  - Учет уже извлеченной информации
  - Поддержка lazy loading
  
- **DecisionAgent** - принятие решений о следующих шагах
  - Комплексный анализ текущего состояния
  - Оценка прогресса задачи
  - Предотвращение циклов

**Механизм:**
- Автоопределение типа агента по задаче и контексту
- Получение рекомендаций от специализированного агента через OpenAI
- Добавление рекомендаций в контекст основного агента
- Chain-of-thought анализ с учетом истории действий
- **query_dom()** - прямой запрос к DOM Sub-agent для получения информации о структуре страницы

### 9. AgentStateManager (`src/agent/agent_state.py`)
**Ответственность:** Управление состоянием агента

**Отслеживает:**
- Текущее состояние агента (AgentState enum)
- История действий с результатами
- Посещенные URL (нормализованные)
- Количество итераций
- Последняя ошибка

**Обнаружение циклов:**
- Анализ повторяющихся действий БЕЗ изменения страницы
- Проверка повторяющихся URL БЕЗ изменения страницы
- Обнаружение паттернов повторения (A-B-A-B)
- Учет появления новых элементов (модальные окна, формы)
- Агрессивное обнаружение с порогом 3 повторения
- Специальная проверка для extract_text с одинаковым описанием

**Особенности:**
- Нормализация URL для сравнения (удаление параметров)
- Учет эффективного изменения страницы (URL/заголовок ИЛИ новые элементы)
- Разделение на важные и менее важные действия при обрезке истории

### 10. SessionManager (`src/browser/session_manager.py`)
**Ответственность:** Управление persistent sessions браузера

**Возможности:**
- Создание и управление сессиями
- Получение путей к user data directories
- Список всех сессий
- Удаление сессий

**Механизм:**
- Использование директории `sessions/<session_name>` для каждой сессии
- Интеграция с Playwright `launch_persistent_context`
- Автоматическое сохранение cookies, localStorage, sessionStorage

### 11. CLIInterface (`src/cli/interface.py`)
**Ответственность:** Интерфейс командной строки для взаимодействия с агентом

**Команды:**
- `task <описание>` - выполнение задачи
- `session <name>` - использование сессии
- `list-sessions` - список доступных сессий
- `status` - текущий статус агента
- `help` - справка
- `quit/exit` - выход

**Особенности:**
- Красивый вывод через Rich library
- Обработка прерываний (Ctrl+C)
- Отображение прогресса выполнения задачи
- Запрос подтверждения для деструктивных действий

## Поток выполнения задачи

### 1. Инициализация
```
Пользователь → CLIInterface → BrowserController → MainAgent
```

1. Пользователь вводит задачу через CLI
2. Инициализируется браузер (с persistent session или без)
3. Создается MainAgent с зависимостями:
   - BrowserController
   - PageExtractor
   - ContextManager
   - ActionExecutor
   - SecurityLayer
   - SubAgentManager
   - AgentStateManager
   - ErrorHandler

### 2. Цикл выполнения (OBSERVE-DECIDE-ACT-REFLECT)

```python
while not completed and iterations < max_iterations:
    # OBSERVE - Наблюдение за текущим состоянием страницы
    page_info = extract_page_info()
    page_state = get_page_state_hash()  # DOM-хеш, количество элементов
    location_context = extract_location_context()  # breadcrumbs, секции
    
    # Проверка на циклы
    loop_info = detect_loop()
    if loop_info:
        return error("Обнаружен цикл")
    
    # Подготовка контекста
    context = prepare_context(page_info)
    
    # Опционально: рекомендации от sub-агентов
    if ENABLE_SUB_AGENTS:
        recommendation = sub_agent_manager.get_recommendation(context, task)
        context += recommendation
    
    # DECIDE - Принятие решения о следующем действии
    decision = decide_action(context, task)
    
    # Проверка на завершение задачи
    if decision.action == "task_complete":
        return success
    
    # Сохранение состояния страницы ПЕРЕД действием
    page_state_before = get_page_state_hash()
    
    # ACT - Выполнение действия
    result = execute_action(decision)
    
    # Ожидание загрузки динамического контента
    await sleep(1.5)
    
    # Проверка изменений страницы ПОСЛЕ действия
    page_info_after = extract_page_info()
    page_state_after = get_page_state_hash()
    
    # Обнаружение изменений
    page_changed = (
        url_changed OR 
        title_changed OR 
        dom_changed OR 
        new_modals OR 
        new_forms OR 
        new_interactive_elements
    )
    
    # REFLECT - Рефлексия над результатом
    if not result.success:
        error_analysis = error_handler.handle_error(error, action, context)
        # Добавление рекомендаций в контекст для следующей итерации
    
    # Добавление в историю с информацией об изменении страницы
    add_to_history(decision, result, page_changed, ...)
    
    # Проверка на циклы после ошибки
    loop_info = detect_loop()
    if loop_info:
        return error("Обнаружен цикл")
```

### 3. Принятие решения

**Формирование промпта:**
1. Системный промпт (детальные инструкции по работе с динамическим контентом, циклами, модальными окнами)
2. Контекст страницы:
   - URL и заголовок
   - Местоположение (breadcrumbs, секции, модальные окна)
   - Интерактивные элементы (приоритет модальным окнам и формам)
   - Видимый текст страницы
   - Информация о прогрессе (completed_steps, extracted_info)
3. История действий:
   - Последние 3-5 действий с результатами
   - Информация об изменении страницы (page_changed, dom_changed)
   - Информация о новых элементах (new_modals, new_forms)
   - Предупреждения о циклах
4. Посещенные URL (для возможности возврата)
5. Рекомендации от sub-агентов (опционально)

**Процесс принятия решения:**
1. Проверка размера запроса (MAX_REQUEST_TOKENS)
2. Оптимизация контекста при превышении лимитов
3. Отправка запроса в OpenAI API с tool definitions
4. Парсинг ответа (tool call или task_complete)
5. Валидация параметров действия

### 4. Выполнение действия

**Процесс:**
1. Проверка безопасности через SecurityLayer
2. Валидация параметров через ActionValidator
3. Поиск элемента по описанию (если селектор не указан)
4. Обработка модальных окон (если нужно)
5. Закрытие overlay и баннеров
6. Прокрутка до элемента (если нужно)
7. Выполнение действия через BrowserController
8. Ожидание загрузки динамического контента
9. Проверка появления модальных окон/форм после действия
10. Обработка ошибок с retry логикой

## Управление контекстом

### Ограничения токенов
- **MAX_CONTEXT_TOKENS** = 3000 (контекст страницы)
- **MAX_HISTORY_TOKENS** = 2000 (история действий)
- **MAX_REQUEST_TOKENS** = 25000 (весь запрос: system + user + tools)

### Стратегии оптимизации

**Приоритизация элементов:**
1. Элементы в модальных окнах (приоритет 1000)
2. Элементы в формах (приоритет 500)
3. Элементы с id (приоритет 100)
4. Элементы с классами (приоритет 50)
5. Элементы с текстом (приоритет 25)

**Обрезка истории:**
- Сохранение важных действий (navigate, успешные клики, extract_text)
- Обрезка менее важных (scroll, wait_for_element, неудачные действия)
- Сохранение последних N менее важных действий для контекста

**Агрессивная оптимизация:**
- При превышении лимитов: сокращение текста элементов, обрезка истории до последних 2-5 действий
- Удаление видимого текста страницы при критическом превышении

## Persistent Sessions

**Механизм:**
- Использование `launch_persistent_context` в Playwright
- Сохранение user data directory в `sessions/<session_name>`
- Автоматическое сохранение cookies, localStorage, sessionStorage, IndexedDB

**Использование:**
1. Пользователь создает сессию через `session <name>` ПЕРЕД входом в аккаунты
2. После входа в аккаунт состояние сохраняется автоматически
3. При следующем запуске с той же сессией - аккаунт уже авторизован
4. Переключение между сессиями через команду `session <name>`

**Структура:**
```
sessions/
  ├── my_account/
  │   ├── Default/  (user data directory)
  │   └── ...
  ├── my_session/
  └── ...
```

## Работа с динамическим контентом

### SPA (Single Page Applications)
- **Обнаружение:** URL изменяется без полной перезагрузки страницы
- **Обработка:** Изменение URL = изменение страницы (page_changed = true), даже если заголовок не изменился
- **Ожидание:** После навигации в SPA - подождать 1-2 секунды для загрузки динамического контента

### AJAX и асинхронный контент
- **Обнаружение:** Страница не изменяется сразу после действия (клик, отправка формы)
- **Обработка:** Ожидание 1-2 секунды, затем проверка контекста на новые элементы
- **Новые элементы:** Появление модальных окон, форм без изменения URL = изменение страницы

### Lazy Loading
- **Обнаружение:** Контент загружается при прокрутке страницы
- **Обработка:** После scroll - обязательная проверка контекста на новые элементы
- **Обнаружение конца:** Проверка `is_at_bottom` для предотвращения бесконечной прокрутки

## Работа с модальными окнами и формами

### Обнаружение модальных окон
- Множественные селекторы: `[role="dialog"]`, `.modal`, `[aria-modal="true"]`, и др.
- Проверка видимости через computed styles
- Извлечение информации о кнопках закрытия, формах внутри

### Приоритизация
- Элементы в модальных окнах имеют максимальный приоритет (1000)
- Элементы в формах имеют высокий приоритет (500)
- Модальные окна отображаются первыми в контексте

### Обработка
- Если модальное окно открыто - работа с элементами внутри него ПЕРВОЙ
- Не закрывать модальные окна с формами (они нужны для работы)
- Закрывать только overlay и баннеры перед кликом
- После клика - проверка появления новых модальных окон

## Обнаружение циклов

### Критерии обнаружения
1. **Повторяющиеся действия:** Одно и то же действие с теми же параметрами повторяется 3+ раза подряд БЕЗ изменения страницы И БЕЗ новых элементов
2. **Повторяющиеся URL:** Один и тот же URL посещается 3+ раза подряд БЕЗ изменения страницы
3. **Повторяющиеся ошибки:** Одна и та же ошибка повторяется 3+ раза подряд БЕЗ изменения страницы
4. **Паттерны повторения:** Паттерн A-B-A-B (переход туда-сюда)

### Механизм обнаружения
- Анализ последних 6 действий на повторения
- Учет эффективного изменения страницы (URL/заголовок ИЛИ новые элементы)
- Специальная проверка для extract_text с одинаковым описанием
- Предупреждения в промпте при обнаружении потенциальных циклов

### Реакция на циклы
- Немедленная остановка выполнения задачи
- Возврат детальной информации о цикле
- Предложение пользователю уточнить задачу или разбить на шаги

## Соответствие ТЗ

✅ **Автономный AI-агент**
- Использует OpenAI GPT-4o
- Принимает решения без постоянного участия пользователя
- Обрабатывает многошаговые задачи
- Отслеживает прогресс выполнения

✅ **Автоматизация браузера**
- Программное управление через Playwright
- Поддержка persistent sessions
- Видимый браузер (не headless по умолчанию)
- Поддержка динамического контента (SPA, AJAX, lazy loading)

✅ **Управление контекстом**
- Стратегии работы с ограничениями по токенам
- Оптимизация размера контекста
- Отслеживание прогресса и извлеченной информации

✅ **Продвинутые паттерны**
- Sub-agent architecture с специализированными агентами
- Обработка ошибок с адаптацией через AI
- Security layer для деструктивных действий
- Агрессивное обнаружение циклов
- Работа с модальными окнами и формами

✅ **Соответствие ограничениям**
- Нет заготовок действий (агент сам определяет стратегию)
- Нет преднаписанных селекторов (поиск по описанию)
- Нет подсказок по ссылкам и элементам (универсальный поиск)
- Универсальные паттерны без привязки к конкретным сайтам

## Технологический стек

- **Python 3.8+**
- **Playwright** - автоматизация браузера
- **OpenAI API** - GPT-4o для принятия решений
- **Rich** - красивое CLI оформление
- **tiktoken** - подсчет токенов
- **pydantic** - валидация данных
- **python-dotenv** - управление переменными окружения

## Структура проекта

```
WebJARVIS/
├── main.py                 # Точка входа
├── config/
│   └── config.py          # Конфигурация (OpenAI, браузер, лимиты)
├── src/
│   ├── agent/
│   │   ├── main_agent.py   # Основной агент
│   │   ├── agent_state.py  # Управление состоянием
│   │   └── sub_agents.py   # Sub-агенты
│   ├── browser/
│   │   ├── controller.py   # Контроллер браузера
│   │   ├── page_extractor.py  # Извлечение информации
│   │   └── session_manager.py  # Управление сессиями
│   ├── actions/
│   │   ├── action_executor.py  # Выполнение действий
│   │   ├── action_tools.py     # Определения инструментов для OpenAI
│   │   └── action_validator.py # Валидация параметров
│   ├── context/
│   │   ├── manager.py      # Управление контекстом
│   │   ├── token_optimizer.py  # Оптимизация токенов
│   │   ├── extractor.py    # Извлечение релевантных элементов
│   │   └── prompt_templates.py # Шаблоны промптов
│   ├── security/
│   │   └── security_layer.py   # Проверка безопасности
│   ├── error/
│   │   ├── error_handler.py    # Обработка ошибок
│   │   └── error_patterns.py   # Паттерны ошибок
│   └── cli/
│       └── interface.py    # CLI интерфейс
├── sessions/               # Persistent sessions
├── tests/                  # Тесты
├── requirements.txt        # Зависимости
├── README.md              # Документация
└── ARCHITECTURE.md        # Этот файл
```

## Конфигурация

Все настройки находятся в `config/config.py` и могут быть переопределены через переменные окружения:

- `OPENAI_API_KEY` - API ключ OpenAI (обязательно)
- `OPENAI_MODEL` - модель OpenAI (по умолчанию "gpt-4o")
- `BROWSER_TYPE` - тип браузера (chromium, firefox, webkit)
- `HEADLESS` - запуск в headless режиме (false по умолчанию)
- `MAX_ITERATIONS` - максимальное количество итераций (50)
- `ENABLE_SUB_AGENTS` - включить sub-агентов (true)
- `MAX_CONTEXT_TOKENS` - лимит токенов для контекста (3000)
- `MAX_HISTORY_TOKENS` - лимит токенов для истории (2000)
- `MAX_REQUEST_TOKENS` - лимит токенов для всего запроса (25000)
